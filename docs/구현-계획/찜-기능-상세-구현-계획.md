# 찜 기능 상세 구현 계획 (API 연동 포함)

## 개요

제공된 디자인 코드를 기반으로 실제 API를 연동하여 찜 기능을 구현합니다. 목 데이터는 사용하지 않고 모든 데이터는 백엔드 API에서 가져옵니다.

---

## 1. API 레이어 확장 (`entities/favorite`)

### 1.1 API 함수 추가 (`src/entities/favorite/api/favoriteApi.ts`)

#### 추가할 API 함수들:

```typescript
// 찜 타겟 목록 조회 (페이지용)
export const getFavoriteTargets = () =>
  request<FavoriteTargetsResponseDto>({
    method: 'GET',
    url: '/api/v1/members/me/favorite-targets',
  })

// 레스토랑 맥락용 찜 타겟 조회
export const getRestaurantFavoriteTargets = (restaurantId: number) =>
  request<RestaurantFavoriteTargetsResponseDto>({
    method: 'GET',
    url: `/api/v1/members/me/restaurants/${restaurantId}/favorite-targets`,
  })

// 하위그룹 찜 목록 조회
export const getSubgroupFavoriteRestaurants = (
  subgroupId: number,
  params?: { cursor?: string; size?: number },
) =>
  request<SubgroupFavoriteRestaurantListResponseDto>({
    method: 'GET',
    url: `/api/v1/members/me/subgroups/${subgroupId}/favorites/restaurants${buildQuery(params ?? {})}`,
  })

// 하위그룹 찜 추가
export const addSubgroupFavoriteRestaurant = (
  subgroupId: number,
  payload: FavoriteCreateRequestDto,
) =>
  request<FavoriteCreateResponseDto>({
    method: 'POST',
    url: `/api/v1/members/me/subgroups/${subgroupId}/favorites/restaurants`,
    data: payload,
  })

// 하위그룹 찜 삭제
export const deleteSubgroupFavoriteRestaurant = (subgroupId: number, restaurantId: number) =>
  request<void>({
    method: 'DELETE',
    url: `/api/v1/members/me/subgroups/${subgroupId}/favorites/restaurants/${restaurantId}`,
  })
```

### 1.2 DTO 타입 정의 (`src/entities/favorite/model/dto.ts`)

```typescript
// 찜 타겟 정보
export type FavoriteTargetDto = {
  id: string // 'my' 또는 'subgroup-{subgroupId}'
  type: 'personal' | 'group'
  name: string
  subgroupId?: number // 그룹인 경우만
  groupName?: string // 그룹인 경우만
  favoriteCount?: number // 찜 개수 (선택적)
}

// 찜 타겟 목록 응답
export type FavoriteTargetsResponseDto = SuccessResponse<{
  personal: {
    favoriteCount: number
  }
  subgroups: Array<{
    subgroupId: number
    subgroupName: string
    groupName: string
    favoriteCount: number
  }>
}>

// 레스토랑 찜 타겟 응답 (현재 찜 상태 포함)
export type RestaurantFavoriteTargetsResponseDto = SuccessResponse<{
  personal: {
    isFavorited: boolean
  }
  subgroups: Array<{
    subgroupId: number
    subgroupName: string
    groupName: string
    isFavorited: boolean
  }>
}>

// 하위그룹 찜 음식점 목록 응답
export type SubgroupFavoriteRestaurantListResponseDto =
  CursorPageResponse<FavoriteRestaurantItemDto>
```

### 1.3 타입 정의 (`src/entities/favorite/model/types.ts`)

```typescript
// 찜 타겟 타입
export type FavoriteTarget = {
  id: string // 'my' 또는 'subgroup-{subgroupId}'
  type: 'personal' | 'group'
  name: string
  subgroupId?: number
  groupName?: string
  favoriteCount?: number
  isFavorited?: boolean // 레스토랑 맥락에서만 사용
}

// 찜 탭 타입
export type FavoriteTab = 'personal' | 'group'

// 하위그룹 정보 (그룹 선택 시트용)
export type SubgroupInfo = {
  subgroupId: number
  name: string
  groupName: string
  favoriteCount: number
}
```

---

## 2. 찜 페이지 구현 (`pages/favorites`)

### 2.1 파일 구조

```
src/pages/favorites/
├── FavoritesPage.tsx
├── components/
│   ├── FavoriteCategoryFilter.tsx
│   ├── FavoriteRestaurantCard.tsx
│   └── SubgroupSelectorSheet.tsx
└── index.ts
```

### 2.2 FavoritesPage.tsx 구현

#### 주요 기능:

1. **탭 전환**: 내 찜 / 그룹 찜
2. **그룹 선택**: 그룹 찜 탭에서 하위그룹 선택 시트 표시
3. **찜 목록 조회**: 선택된 탭에 따라 API 호출
4. **찜 해제**: 하트 아이콘 클릭으로 찜 삭제

#### 상태 관리:

```typescript
type FavoritesPageState = {
  // 탭 상태
  selectedTab: FavoriteTab // 'personal' | 'group'
  selectedSubgroupId: number | null

  // 데이터
  favoriteTargets: FavoriteTarget[] // 찜 타겟 목록
  personalFavorites: FavoriteRestaurantItem[] // 내 찜 목록
  subgroupFavorites: FavoriteRestaurantItem[] // 선택된 하위그룹 찜 목록

  // UI 상태
  showSubgroupSelector: boolean
  isLoading: boolean
  error: string | null

  // 페이지네이션
  personalCursor: string | null
  subgroupCursor: string | null
  hasMorePersonal: boolean
  hasMoreSubgroup: boolean
}
```

#### API 호출 흐름:

1. **초기 로드**:

   ```typescript
   // 1. 찜 타겟 목록 조회
   const targets = await getFavoriteTargets()

   // 2. 내 찜 목록 조회 (기본 선택)
   const personalFavs = await getMyFavoriteRestaurants({ cursor: null })
   ```

2. **그룹 탭 선택 시**:

   ```typescript
   // 첫 번째 하위그룹 선택 또는 이전 선택 유지
   if (!selectedSubgroupId && targets.subgroups.length > 0) {
     setSelectedSubgroupId(targets.subgroups[0].subgroupId)
   }

   // 선택된 하위그룹 찜 목록 조회
   const subgroupFavs = await getSubgroupFavoriteRestaurants(selectedSubgroupId)
   ```

3. **하위그룹 변경 시**:

   ```typescript
   // 새로운 하위그룹 찜 목록 조회
   const newSubgroupFavs = await getSubgroupFavoriteRestaurants(newSubgroupId)
   ```

4. **찜 해제**:
   ```typescript
   if (selectedTab === 'personal') {
     await deleteMyFavoriteRestaurant(restaurantId)
   } else {
     await deleteSubgroupFavoriteRestaurant(selectedSubgroupId, restaurantId)
   }
   ```

#### 컴포넌트 구조:

```tsx
<FavoritesPage>
  <TopAppBar title="찜" />

  <FavoriteCategoryFilter
    selectedTab={selectedTab}
    selectedSubgroup={selectedSubgroup}
    favoriteTargets={favoriteTargets}
    onTabChange={setSelectedTab}
    onSubgroupClick={() => setShowSubgroupSelector(true)}
  />

  <Container>
    {isLoading ? (
      <LoadingState />
    ) : error ? (
      <ErrorState error={error} />
    ) : restaurants.length === 0 ? (
      <EmptyState />
    ) : (
      <RestaurantList>
        {restaurants.map((restaurant) => (
          <FavoriteRestaurantCard
            key={restaurant.restaurantId}
            restaurant={restaurant}
            onRemove={() => handleRemoveFavorite(restaurant.restaurantId)}
            onClick={() => onRestaurantClick(String(restaurant.restaurantId))}
          />
        ))}
      </RestaurantList>
    )}
  </Container>

  <SubgroupSelectorSheet
    open={showSubgroupSelector}
    onClose={() => setShowSubgroupSelector(false)}
    subgroups={favoriteTargets.filter((t) => t.type === 'group')}
    selectedSubgroupId={selectedSubgroupId}
    onSelect={(subgroupId) => {
      setSelectedSubgroupId(subgroupId)
      setSelectedTab('group')
    }}
  />
</FavoritesPage>
```

### 2.3 FavoriteCategoryFilter.tsx

#### Props:

```typescript
type FavoriteCategoryFilterProps = {
  selectedTab: FavoriteTab
  selectedSubgroup: FavoriteTarget | null
  favoriteTargets: FavoriteTarget[]
  personalCount: number
  onTabChange: (tab: FavoriteTab) => void
  onSubgroupClick: () => void
}
```

#### 구현:

```tsx
export function FavoriteCategoryFilter({
  selectedTab,
  selectedSubgroup,
  favoriteTargets,
  personalCount,
  onTabChange,
  onSubgroupClick,
}: FavoriteCategoryFilterProps) {
  return (
    <div className="sticky top-0 z-10 bg-background border-b border-border">
      <Container>
        <div className="flex gap-2 py-3">
          {/* 내 찜 탭 */}
          <button
            onClick={() => onTabChange('personal')}
            className={cn(
              'flex items-center gap-2 px-4 py-2 rounded-full whitespace-nowrap transition-all',
              selectedTab === 'personal'
                ? 'bg-primary text-white'
                : 'bg-accent text-foreground hover:bg-accent/80',
            )}
          >
            <Heart className="w-4 h-4" />
            <span className="text-sm font-medium">내 찜</span>
            <Badge
              variant={selectedTab === 'personal' ? 'secondary' : 'outline'}
              className={cn(
                'ml-1',
                selectedTab === 'personal' && 'bg-white/20 text-white border-white/30',
              )}
            >
              {personalCount}
            </Badge>
          </button>

          {/* 그룹 찜 탭 */}
          <button
            onClick={onSubgroupClick}
            className={cn(
              'flex items-center gap-2 px-4 py-2 rounded-full whitespace-nowrap transition-all',
              selectedTab === 'group'
                ? 'bg-primary text-white'
                : 'bg-accent text-foreground hover:bg-accent/80',
            )}
          >
            <Users className="w-4 h-4" />
            <span className="text-sm font-medium">
              {selectedTab === 'group' && selectedSubgroup ? selectedSubgroup.name : '그룹 찜'}
            </span>
            {selectedTab === 'group' && selectedSubgroup && (
              <Badge variant="secondary" className="ml-1 bg-white/20 text-white border-white/30">
                {selectedSubgroup.favoriteCount || 0}
              </Badge>
            )}
            <ChevronDown className="w-4 h-4" />
          </button>
        </div>
      </Container>
    </div>
  )
}
```

### 2.4 FavoriteRestaurantCard.tsx

#### Props:

```typescript
type FavoriteRestaurantCardProps = {
  restaurant: FavoriteRestaurantItem
  onRemove: (e: React.MouseEvent) => void
  onClick: () => void
}
```

#### 구현:

```tsx
export function FavoriteRestaurantCard({
  restaurant,
  onRemove,
  onClick,
}: FavoriteRestaurantCardProps) {
  return (
    <Card
      className="overflow-hidden cursor-pointer hover:shadow-md transition-shadow"
      onClick={onClick}
    >
      <CardContent className="p-0">
        <div className="flex gap-3">
          {/* 이미지 */}
          <div className="relative w-24 h-24 flex-shrink-0">
            <ImageWithFallback
              src={restaurant.thumbnailUrl || ''}
              alt={restaurant.name}
              className="w-full h-full object-cover"
            />
          </div>

          {/* 정보 */}
          <div className="flex-1 py-3 pr-3 min-w-0">
            <div className="flex items-start justify-between mb-2">
              <div className="flex-1 min-w-0">
                <h4 className="truncate mb-1">{restaurant.name}</h4>
                {/* 카테고리는 API에서 제공되지 않으면 표시하지 않음 */}
              </div>
              <button
                onClick={onRemove}
                className="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full hover:bg-accent transition-colors ml-2"
              >
                <Heart className="w-5 h-5 text-primary fill-primary" />
              </button>
            </div>

            {/* 주소는 API에서 제공되는 경우에만 표시 */}
            {restaurant.address && (
              <p className="caption text-muted-foreground mt-1 truncate">
                <MapPin className="w-3 h-3 inline mr-1" />
                {restaurant.address}
              </p>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
```

### 2.5 SubgroupSelectorSheet.tsx

#### Props:

```typescript
type SubgroupSelectorSheetProps = {
  open: boolean
  onClose: () => void
  subgroups: FavoriteTarget[] // type === 'group'인 것만
  selectedSubgroupId: number | null
  onSelect: (subgroupId: number) => void
}
```

#### 구현:

```tsx
export function SubgroupSelectorSheet({
  open,
  onClose,
  subgroups,
  selectedSubgroupId,
  onSelect,
}: SubgroupSelectorSheetProps) {
  if (!open) return null

  const handleSelect = (subgroupId: number) => {
    onSelect(subgroupId)
    onClose()
  }

  return (
    <Sheet open={open} onOpenChange={onClose}>
      <SheetContent side="bottom" className="max-h-[80vh]">
        <SheetHeader>
          <SheetTitle>그룹 선택</SheetTitle>
          <SheetDescription>찜 목록을 볼 그룹을 선택하세요</SheetDescription>
        </SheetHeader>

        <div className="max-h-[60vh] overflow-auto space-y-2">
          {subgroups.map((subgroup) => {
            const isSelected = selectedSubgroupId === subgroup.subgroupId
            return (
              <button
                key={subgroup.id}
                onClick={() => handleSelect(subgroup.subgroupId!)}
                className={cn(
                  'w-full flex items-center justify-between p-4 rounded-lg border transition-all',
                  isSelected ? 'border-primary bg-primary/5' : 'border-border hover:bg-accent',
                )}
              >
                <div className="flex items-center gap-3">
                  <div
                    className={cn(
                      'flex items-center justify-center w-10 h-10 rounded-full',
                      isSelected ? 'bg-primary/10' : 'bg-blue-500/10',
                    )}
                  >
                    <Users
                      className={cn('w-5 h-5', isSelected ? 'text-primary' : 'text-blue-600')}
                    />
                  </div>
                  <div className="text-left">
                    <p className="font-semibold text-sm">{subgroup.name}</p>
                    <p className="caption text-muted-foreground">
                      {subgroup.groupName && `${subgroup.groupName} • `}
                      찜한 맛집 {subgroup.favoriteCount || 0}개
                    </p>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  {subgroup.favoriteCount !== undefined && (
                    <Badge variant="outline">{subgroup.favoriteCount}</Badge>
                  )}
                  {isSelected && (
                    <div className="flex items-center justify-center w-6 h-6 rounded-full bg-primary">
                      <Check className="w-4 h-4 text-white" />
                    </div>
                  )}
                </div>
              </button>
            )
          })}
        </div>
      </SheetContent>
    </Sheet>
  )
}
```

---

## 3. 찜 선택 시트 구현 (`features/favorites`)

### 3.1 파일 구조

```
src/features/favorites/
├── FavoriteSelectionSheet.tsx
├── components/
│   └── FavoriteTargetItem.tsx
└── index.ts
```

### 3.2 FavoriteSelectionSheet.tsx

#### Props:

```typescript
type FavoriteSelectionSheetProps = {
  open: boolean
  onOpenChange: (open: boolean) => void
  restaurantId: number
  restaurantName: string
  onComplete: (selectedTargets: string[]) => void // ['my', 'subgroup-1', 'subgroup-2']
}
```

#### 상태 관리:

```typescript
type FavoriteSelectionState = {
  targets: FavoriteTarget[] // 찜 타겟 목록
  selectedTargets: Set<string> // 선택된 타겟 ID들
  isLoading: boolean
  error: string | null
}
```

#### API 호출 흐름:

1. **시트 열릴 때**:

   ```typescript
   // 레스토랑 찜 타겟 조회 (현재 찜 상태 포함)
   const response = await getRestaurantFavoriteTargets(restaurantId)

   // 현재 찜 상태를 기반으로 초기 선택 설정
   const initialSelected = new Set<string>()
   if (response.personal.isFavorited) {
     initialSelected.add('my')
   }
   response.subgroups.forEach((subgroup) => {
     if (subgroup.isFavorited) {
       initialSelected.add(`subgroup-${subgroup.subgroupId}`)
     }
   })
   ```

2. **타겟 토글**:

   ```typescript
   const handleToggle = async (targetId: string) => {
     const target = targets.find((t) => t.id === targetId)
     if (!target) return

     const isSelected = selectedTargets.has(targetId)

     if (target.type === 'personal') {
       // 내 찜 추가/삭제
       if (isSelected) {
         await deleteMyFavoriteRestaurant(restaurantId)
       } else {
         await addMyFavoriteRestaurant({ restaurantId })
       }
     } else {
       // 하위그룹 찜 추가/삭제
       if (isSelected) {
         await deleteSubgroupFavoriteRestaurant(target.subgroupId!, restaurantId)
       } else {
         await addSubgroupFavoriteRestaurant(target.subgroupId!, { restaurantId })
       }
     }

     // 선택 상태 업데이트
     setSelectedTargets((prev) => {
       const next = new Set(prev)
       if (isSelected) {
         next.delete(targetId)
       } else {
         next.add(targetId)
       }
       return next
     })
   }
   ```

3. **완료 버튼**:
   ```typescript
   const handleComplete = () => {
     onComplete(Array.from(selectedTargets))
     onOpenChange(false)
   }
   ```

#### 컴포넌트 구조:

```tsx
<FavoriteSelectionSheet>
  <SheetContent side="bottom">
    <SheetHeader>
      <SheetTitle>찜 목록에 추가</SheetTitle>
      <SheetDescription>{restaurantName}를 저장할 목록을 선택하세요</SheetDescription>
    </SheetHeader>

    <div className="max-h-[60vh] overflow-auto space-y-2">
      {targets.map((target) => (
        <FavoriteTargetItem
          key={target.id}
          target={target}
          isSelected={selectedTargets.has(target.id)}
          onToggle={() => handleToggle(target.id)}
        />
      ))}
    </div>

    <SheetFooter>
      <Button onClick={handleComplete} className="w-full" size="lg">
        완료
      </Button>
    </SheetFooter>
  </SheetContent>
</FavoriteSelectionSheet>
```

### 3.3 FavoriteTargetItem.tsx

#### Props:

```typescript
type FavoriteTargetItemProps = {
  target: FavoriteTarget
  isSelected: boolean
  onToggle: () => void
}
```

#### 구현:

```tsx
export function FavoriteTargetItem({ target, isSelected, onToggle }: FavoriteTargetItemProps) {
  const isPersonal = target.type === 'personal'

  return (
    <button
      onClick={onToggle}
      className={cn(
        'w-full flex items-center justify-between p-4 rounded-lg border transition-all',
        isSelected ? 'border-primary bg-primary/5' : 'border-border hover:bg-accent',
      )}
    >
      <div className="flex items-center gap-3">
        <div
          className={cn(
            'flex items-center justify-center w-10 h-10 rounded-full',
            isPersonal ? 'bg-primary/10' : 'bg-blue-500/10',
          )}
        >
          {isPersonal ? (
            <Heart
              className={cn('w-5 h-5', isSelected ? 'text-primary fill-primary' : 'text-primary')}
            />
          ) : (
            <Users className="w-5 h-5 text-blue-600" />
          )}
        </div>
        <div className="text-left">
          <p className="font-semibold text-sm">{target.name}</p>
          {!isPersonal && (
            <p className="caption text-muted-foreground">
              {target.groupName && `${target.groupName} • `}
              그룹 찜 목록
            </p>
          )}
        </div>
      </div>
      {isSelected && (
        <div className="flex items-center justify-center w-6 h-6 rounded-full bg-primary">
          <Check className="w-4 h-4 text-white" />
        </div>
      )}
    </button>
  )
}
```

---

## 4. 음식점 상세 페이지 통합

### 4.1 RestaurantDetailPage.tsx 수정

#### 추가할 상태:

```typescript
const [showFavoriteSheet, setShowFavoriteSheet] = React.useState(false)
const [favoriteStatus, setFavoriteStatus] = React.useState<{
  personal: boolean
  subgroups: Array<{ subgroupId: number; isFavorited: boolean }>
} | null>(null)
```

#### 찜 버튼 추가:

```tsx
// TopAppBar actions에 추가
<TopAppBar
  title={restaurantData?.name}
  showBackButton
  onBack={() => navigate(-1)}
  actions={
    <button
      onClick={() => setShowFavoriteSheet(true)}
      className="w-10 h-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors"
      aria-label="찜하기"
    >
      <Heart
        className={cn(
          'w-5 h-5',
          favoriteStatus?.personal ? 'text-primary fill-primary' : 'text-muted-foreground',
        )}
      />
    </button>
  }
/>
```

#### 찜 상태 조회:

```typescript
React.useEffect(() => {
  if (!restaurantId) return

  // 찜 상태 조회
  getRestaurantFavoriteStatus(Number(restaurantId))
    .then((response) => {
      setFavoriteStatus({
        personal: response.myFavorite.favoriteState === 'FAVORITED_BY_ME',
        subgroups: response.groupFavorites.map((gf) => ({
          subgroupId: gf.subgroupId,
          isFavorited: gf.favoriteState === 'FAVORITED_BY_ME',
        })),
      })
    })
    .catch(() => {
      // 에러 처리
    })
}, [restaurantId])
```

#### 찜 선택 시트 통합:

```tsx
<FavoriteSelectionSheet
  open={showFavoriteSheet}
  onOpenChange={setShowFavoriteSheet}
  restaurantId={Number(restaurantId)}
  restaurantName={restaurantData?.name || ''}
  onComplete={(selectedTargets) => {
    // 완료 후 찜 상태 재조회
    getRestaurantFavoriteStatus(Number(restaurantId)).then((response) => {
      setFavoriteStatus({
        personal: response.myFavorite.favoriteState === 'FAVORITED_BY_ME',
        subgroups: response.groupFavorites.map((gf) => ({
          subgroupId: gf.subgroupId,
          isFavorited: gf.favoriteState === 'FAVORITED_BY_ME',
        })),
      })
    })
    toast.success('찜 목록이 업데이트되었습니다')
  }}
/>
```

---

## 5. 하단 탭바 수정

### 5.1 BottomTabBar.tsx 수정

```typescript
// TabId 타입 확장
export type TabId = 'home' | 'search' | 'favorites' | 'groups' | 'profile'

// tabs 배열에 찜 탭 추가
const tabs = [
  { id: 'home' as const, icon: Home, label: '홈' },
  { id: 'search' as const, icon: Search, label: '검색' },
  { id: 'favorites' as const, icon: Heart, label: '찜' }, // 추가
  { id: 'groups' as const, icon: Users, label: '그룹' },
  { id: 'profile' as const, icon: User, label: '프로필' },
]
```

### 5.2 라우팅 추가 (`AppRouter.tsx`)

```typescript
const FavoritesPage = lazy(() =>
  import('@/pages/favorites').then((m) => ({ default: m.FavoritesPage })),
)

// Route 추가
<Route
  path="/favorites"
  element={
    <RequireAuth>
      <FavoritesPage
        onRestaurantClick={(id) => navigate(`/restaurants/${id}`)}
      />
    </RequireAuth>
  }
/>
```

### 5.3 각 페이지의 탭 변경 핸들러 업데이트

```typescript
// HomePage, SearchPage, GroupsPage, ProfilePage 모두 수정
onTabChange={(tab: TabId) => {
  if (tab === 'favorites') {
    navigate(ROUTES.favorites)
  } else if (tab === 'home') {
    navigate(ROUTES.home)
  }
  // ... 기타 탭 처리
}}
```

### 5.4 routes.ts 업데이트

```typescript
export const ROUTES = {
  // ... 기존 routes
  favorites: '/favorites',
} as const
```

---

## 6. 에러 처리 및 로딩 상태

### 6.1 에러 처리

```typescript
// API 호출 시 에러 처리
try {
  const data = await getMyFavoriteRestaurants()
  // 성공 처리
} catch (error) {
  if (error.response?.status === 401) {
    // 인증 에러 - 로그인 페이지로 리다이렉트
  } else if (error.response?.status === 404) {
    // 리소스 없음
    toast.error('찜 목록을 찾을 수 없습니다')
  } else {
    // 기타 에러
    toast.error('오류가 발생했습니다. 다시 시도해주세요')
  }
}
```

### 6.2 로딩 상태

```typescript
// 로딩 인디케이터 표시
{isLoading ? (
  <div className="flex items-center justify-center py-12">
    <Skeleton className="h-40 w-full" />
  </div>
) : (
  // 콘텐츠 표시
)}
```

---

## 7. 최적화 고려사항

### 7.1 캐싱

- 찜 타겟 목록은 세션 스토리지에 캐싱
- 찜 목록은 React Query 또는 SWR 사용 고려

### 7.2 페이지네이션

- 무한 스크롤 또는 "더 보기" 버튼으로 추가 로드
- 커서 기반 페이지네이션 활용

### 7.3 낙관적 업데이트

- 찜 추가/삭제 시 즉시 UI 업데이트
- 실패 시 롤백

---

## 8. 구현 순서

1. **API 레이어 확장** (`entities/favorite`)
   - API 함수 추가
   - DTO 타입 정의
   - 타입 정의

2. **찜 선택 시트 구현** (`features/favorites`)
   - FavoriteSelectionSheet
   - FavoriteTargetItem

3. **음식점 상세 페이지 통합**
   - 찜 버튼 추가
   - 시트 연동

4. **하단 탭바 수정**
   - 찜 탭 추가
   - 라우팅 설정

5. **찜 페이지 구현** (`pages/favorites`)
   - FavoritesPage
   - FavoriteCategoryFilter
   - FavoriteRestaurantCard
   - SubgroupSelectorSheet

6. **통합 테스트 및 최적화**
   - 에러 처리
   - 로딩 상태
   - 캐싱

---

## 9. 주의사항

1. **인증**: 모든 찜 관련 API는 인증 필요 (`RequireAuth` 사용)
2. **에러 처리**: 네트워크 에러, 인증 에러 등 모든 경우 처리
3. **로딩 상태**: 사용자 경험을 위한 적절한 로딩 인디케이터
4. **데이터 동기화**: 찜 추가/삭제 후 관련 데이터 재조회
5. **접근성**: 키보드 네비게이션 및 스크린 리더 지원
